// Aspirational Test 03: Arrays, Error Handling, and Advanced Features
// This file tests collections, error handling, and advanced language features

import io
import fs
import json

// Array literals and operations
let numbers := [1, 2, 3, 4, 5]
let names := ["Alice", "Bob", "Charlie"]
let empty: [int] = []

io.println "First number: {}", numbers[0]
io.println "Last number: {}", numbers[4]

// Array length
io.println "Array length: {}", numbers.len()

// Array append
numbers.append(6)
io.println "After append: {}", numbers

// Array iteration
io.println "All numbers:"
for num in numbers {
  io.println "  {}", num
}

io.println "All names:"
for i, name in names {
  io.println "  {}: {}", i, name
}

// Array slicing
let slice := numbers[1:4]  // [2, 3, 4]
io.println "Slice [1:4]: {}", slice

// Array methods
let sum := numbers.sum()
io.println "Sum: {}", sum

let max := numbers.max()
io.println "Max: {}", max

// Map and filter (higher-order functions)
let doubled := numbers.map(fn(x) -> x * 2)
io.println "Doubled: {}", doubled

let evens := numbers.filter(fn(x) -> x % 2 == 0)
io.println "Even numbers: {}", evens

// Hash map / dictionary
let scores := {
  "Alice": 95,
  "Bob": 87,
  "Charlie": 92
}

io.println "Alice's score: {}", scores["Alice"]

scores["David"] = 88
io.println "After adding David: {}", scores

// Check if key exists
if "Alice" in scores {
  io.println "Alice is in the scores"
}

// Iterate over map
for name, score in scores {
  io.println "{}: {}", name, score
}

// Error handling with 'or' operator
let content := fs.read_file("data.txt") or {
  io.println "Failed to read file, using default"
  "default content"
}

io.println "File content: {}", content

// Error handling with explicit error type
fn divide(a: int, b: int) -> int or error {
  if b == 0 {
    return error("Division by zero")
  }
  return a / b
}

let result := divide(10, 2) or {
  io.println "Division failed"
  0
}
io.println "Division result: {}", result

// Try dividing by zero
let bad_result := divide(10, 0) or {
  io.println "Cannot divide by zero, using 0"
  0
}

// Defer for cleanup
fn process_file(filename: string) {
  let file := fs.open(filename) or return
  defer file.close()  // Will execute when function returns
  
  let data := file.read()
  io.println "File data: {}", data
}

// Match expressions (pattern matching)
let value := 42

let description := match value {
  0 -> "zero",
  1..10 -> "small",
  11..100 -> "medium",
  _ -> "large"
}

io.println "Value {} is {}", value, description

// Enum types
enum Color {
  Red,
  Green,
  Blue,
  RGB(int, int, int)
}

let favorite := Color.Blue
let custom := Color.RGB(128, 64, 255)

match favorite {
  Color.Red -> io.println "Favorite is red",
  Color.Green -> io.println "Favorite is green",
  Color.Blue -> io.println "Favorite is blue",
  Color.RGB(r, g, b) -> io.println "Custom color: {}, {}, {}", r, g, b
}

// JSON parsing
let json_str := '{"name": "Satori", "version": "0.1.0"}'
let data := json.parse(json_str) or {
  io.println "Failed to parse JSON"
  {}
}

io.println "Project: {}", data["name"]
io.println "Version: {}", data["version"]

// Concurrency (spawn and channels)
fn worker(id: int, jobs: chan int, results: chan int) {
  for job in jobs {
    io.println "Worker {} processing job {}", id, job
    results <- job * 2
  }
}

let jobs := make(chan int, 10)
let results := make(chan int, 10)

// Spawn 3 workers
for w := 1; w <= 3; w = w + 1 {
  spawn worker(w, jobs, results)
}

// Send 5 jobs
for j := 1; j <= 5; j = j + 1 {
  jobs <- j
}
close(jobs)

// Collect results
for i := 1; i <= 5; i = i + 1 {
  let result := <-results
  io.println "Result: {}", result
}

// String methods
let text := "  Hello, Satori!  "
io.println "Original: '{}'", text
io.println "Trimmed: '{}'", text.trim()
io.println "Uppercase: '{}'", text.to_upper()
io.println "Lowercase: '{}'", text.to_lower()
io.println "Contains 'Satori': {}", text.contains("Satori")
io.println "Starts with '  Hello': {}", text.starts_with("  Hello")
io.println "Split: {}", text.split(",")
